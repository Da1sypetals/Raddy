#![allow(unused)]

use crate::{commutative::Commutative, norms::AdMatrixOps, Ad, GetValue};
use approx::assert_abs_diff_eq;
use nalgebra::{Const, DimName, Matrix3, SMatrix, SVector, U3, U5};
use rand::{thread_rng, Rng};
use std::any::Any;

const EPS: f64 = 1e-12;
const RELRATIO: f64 = 6e-4;

fn float_close(left: f64, right: f64) {
    let diff = (left - right).abs();
    assert!(
        diff / left.abs() < RELRATIO,
        "\n  left = {}\n  right = {}\n  rel = {}\n",
        left,
        right,
        diff / left.abs()
    );
    assert!(
        diff / right.abs() < RELRATIO,
        "\n  left = {}\n  right = {}\n  rel = {}\n",
        left,
        right,
        diff / left.abs()
    );
}

/*

* Code generated by Symars. Thank you for using Symars!
  Symars is licensed under MIT licnese.
  Repository: https://github.com/Da1sypetals/Symars

* Computation code is not intended for manual editing.

* If you find an error,
  or if you believe Symars generates incorrect result,
  please raise an issue under our repo with minimal reproducible example.

*/

#[inline]
pub fn grad_0(s: f64) -> f64 {
    let __intermediate_result_5 = (s).powi(2);
    let __intermediate_result_7 = (s).cosh();
    let __intermediate_result_10 = (s).sinh();

    ((1.0000000000000000000_f64)
        + (-(((s).tanh()).powi(2)))
        + ((1.24500000000000_f64)
            * (__intermediate_result_5)
            * ((__intermediate_result_7).powi(2)))
        + ((1.24500000000000_f64)
            * (__intermediate_result_5)
            * ((__intermediate_result_10).powi(2)))
        + ((2.49000000000000_f64) * (s) * (__intermediate_result_7) * (__intermediate_result_10)))
}

#[inline]
pub fn hess_0(s: f64) -> f64 {
    let __intermediate_result_5 = (s).tanh();
    let __intermediate_result_7 = (s).cosh();
    let __intermediate_result_8 = (s).sinh();

    ((-(((2.0000000000000000000_f64)
        + ((-2.0000000000000000000_f64) * ((__intermediate_result_5).powi(2))))
        * (__intermediate_result_5)))
        + ((2.49000000000000_f64) * (__intermediate_result_7) * (__intermediate_result_8))
        + ((4.98000000000000_f64) * (s) * ((__intermediate_result_7).powi(2)))
        + ((4.98000000000000_f64) * (s) * ((__intermediate_result_8).powi(2)))
        + ((4.98000000000000_f64)
            * ((s).powi(2))
            * (__intermediate_result_7)
            * (__intermediate_result_8)))
}

// code generated by symars (sympy)
pub fn grad_1(s: f64) -> f64 {
    (((0.50000000000000000000_f64) * ((s).powf(-0.50000000000000000000_f64)))
        + (((s).powf(1.30000000000000_f64)) * ((s).sin()))
        + (((s).asinh()) * ((s).tan()))
        + ((-1.30000000000000_f64) * ((s).powf(0.300000000000000_f64)) * ((s).cos()))
        + ((s)
            * (((1.0000000000000000000_f64) + ((s).powi(2))).powf(-0.50000000000000000000_f64))
            * ((s).tan()))
        + ((s) * ((1.0000000000000000000_f64) + (((s).tan()).powi(2))) * ((s).asinh())))
}

pub fn hess_1(s: f64) -> f64 {
    let __intermediate_result_8 = ((1.0000000000000000000_f64) + ((s).powi(2)));
    let __intermediate_result_10 = (s).tan();
    let __intermediate_result_13 = ((s).tan()).powi(2);

    (((-0.25000000000000000000_f64) * ((s).powf(-1.5000000000000000000_f64)))
        + (((s).powf(1.30000000000000_f64)) * ((s).cos()))
        + ((2.0000000000000000000_f64)
            * ((__intermediate_result_8).powf(-0.50000000000000000000_f64))
            * (__intermediate_result_10))
        + ((2.0000000000000000000_f64)
            * ((1.0000000000000000000_f64) + (__intermediate_result_13))
            * ((s).asinh()))
        + ((2.60000000000000_f64) * ((s).powf(0.300000000000000_f64)) * ((s).sin()))
        + ((-0.390000000000000_f64) * ((s).powf(-0.700000000000000_f64)) * ((s).cos()))
        + (-(((s).powi(2))
            * ((__intermediate_result_8).powf(-1.5000000000000000000_f64))
            * (__intermediate_result_10)))
        + ((2.0000000000000000000_f64)
            * (s)
            * ((__intermediate_result_8).powf(-0.50000000000000000000_f64))
            * ((1.0000000000000000000_f64) + (__intermediate_result_13)))
        + ((s)
            * ((2.0000000000000000000_f64)
                + ((2.0000000000000000000_f64) * (__intermediate_result_13)))
            * ((s).asinh())
            * (__intermediate_result_10)))
}

pub fn grad_2(s: f64) -> f64 {
    let __intermediate_result_12 = (s).powi(2);
    let __intermediate_result_15 = (s).atanh();
    let __intermediate_result_16 = (s).tan();
    let __intermediate_result_21 = (s).asinh();

    ((-0.693962526023595_f64)
        + ((0.50000000000000000000_f64) * ((s).powf(-0.50000000000000000000_f64)))
        + ((-5.23500000000000_f64) * ((s).powi(-2)))
        + (((s).powf(1.30000000000000_f64)) * ((s).sin()))
        + ((-1.30000000000000_f64) * ((s).powf(0.300000000000000_f64)) * ((s).cos()))
        + ((__intermediate_result_12)
            * (((1.0000000000000000000_f64) + (__intermediate_result_12))
                .powf(-0.50000000000000000000_f64))
            * (__intermediate_result_15)
            * (__intermediate_result_16))
        + ((__intermediate_result_12)
            * (((1.0000000000000000000_f64) + (-(__intermediate_result_12))).recip())
            * (__intermediate_result_21)
            * (__intermediate_result_16))
        + ((__intermediate_result_12)
            * ((1.0000000000000000000_f64) + ((__intermediate_result_16).powi(2)))
            * (__intermediate_result_21)
            * (__intermediate_result_15))
        + ((2.0000000000000000000_f64)
            * (s)
            * (__intermediate_result_21)
            * (__intermediate_result_15)
            * (__intermediate_result_16)))
}

pub fn hess_2(s: f64) -> f64 {
    let __intermediate_result_7 = (s).cos();
    let __intermediate_result_14 = (s).asinh();
    let __intermediate_result_15 = (s).atanh();
    let __intermediate_result_16 = (s).tan();
    let __intermediate_result_18 = (s).powi(3);
    let __intermediate_result_21 = (s).powi(2);
    let __intermediate_result_23 =
        ((1.0000000000000000000_f64) + ((s).powi(2))).powf(-0.50000000000000000000_f64);
    let __intermediate_result_24 = ((1.0000000000000000000_f64) + (-((s).powi(2)))).recip();
    let __intermediate_result_28 = ((1.0000000000000000000_f64) + (((s).tan()).powi(2)));

    (((-0.25000000000000000000_f64) * ((s).powf(-1.5000000000000000000_f64)))
        + ((10.4700000000000_f64) * ((s).powi(-3)))
        + (((s).powf(1.30000000000000_f64)) * (__intermediate_result_7))
        + ((2.60000000000000_f64) * ((s).powf(0.300000000000000_f64)) * ((s).sin()))
        + ((-0.390000000000000_f64)
            * ((s).powf(-0.700000000000000_f64))
            * (__intermediate_result_7))
        + ((2.0000000000000000000_f64)
            * (__intermediate_result_14)
            * (__intermediate_result_15)
            * (__intermediate_result_16))
        + (-((__intermediate_result_18)
            * (((1.0000000000000000000_f64) + (__intermediate_result_21))
                .powf(-1.5000000000000000000_f64))
            * (__intermediate_result_15)
            * (__intermediate_result_16)))
        + ((2.0000000000000000000_f64)
            * (__intermediate_result_21)
            * (__intermediate_result_23)
            * (__intermediate_result_24)
            * (__intermediate_result_16))
        + ((2.0000000000000000000_f64)
            * (__intermediate_result_21)
            * (__intermediate_result_23)
            * (__intermediate_result_28)
            * (__intermediate_result_15))
        + ((2.0000000000000000000_f64)
            * (__intermediate_result_21)
            * (__intermediate_result_24)
            * (__intermediate_result_28)
            * (__intermediate_result_14))
        + ((2.0000000000000000000_f64)
            * (__intermediate_result_18)
            * (((1.0000000000000000000_f64) + (-(__intermediate_result_21))).powi(-2))
            * (__intermediate_result_14)
            * (__intermediate_result_16))
        + ((4.0000000000000000000_f64)
            * (s)
            * (__intermediate_result_23)
            * (__intermediate_result_15)
            * (__intermediate_result_16))
        + ((4.0000000000000000000_f64)
            * (s)
            * (__intermediate_result_24)
            * (__intermediate_result_14)
            * (__intermediate_result_16))
        + ((4.0000000000000000000_f64)
            * (s)
            * (__intermediate_result_28)
            * (__intermediate_result_14)
            * (__intermediate_result_15))
        + ((__intermediate_result_21)
            * ((2.0000000000000000000_f64)
                + ((2.0000000000000000000_f64) * ((__intermediate_result_16).powi(2))))
            * (__intermediate_result_14)
            * (__intermediate_result_15)
            * (__intermediate_result_16)))
}

pub fn grad_3(s: f64) -> f64 {
    let __intermediate_result_9 = (s).powf(1.30000000000000_f64);
    let __intermediate_result_12 = (s).powi(2);
    let __intermediate_result_14 = (s).powi(3);
    let __intermediate_result_17 = (s).cos();
    let __intermediate_result_19 = ((s).asinh()).powi(2);
    let __intermediate_result_23 = (s).tan();

    (((-0.693962526023595_f64)
        + ((0.50000000000000000000_f64) * ((s).powf(-0.50000000000000000000_f64)))
        + ((-27.7760000000000_f64) * ((s).powf(-3.24000000000000_f64)))
        + ((-5.23500000000000_f64) * ((s).powi(-2)))
        + ((__intermediate_result_9) * ((s).sin()))
        + ((-3.0000000000000000000_f64)
            * (__intermediate_result_12)
            * ((__intermediate_result_14).cosh()))
        + ((-1.30000000000000_f64)
            * ((s).powf(0.300000000000000_f64))
            * (__intermediate_result_17))
        + ((__intermediate_result_12)
            * (__intermediate_result_19)
            * ((1.0000000000000000000_f64) + ((__intermediate_result_23).powi(2))))
        + ((2.0000000000000000000_f64)
            * (s)
            * (__intermediate_result_19)
            * (__intermediate_result_23))
        + ((2.0000000000000000000_f64)
            * (__intermediate_result_12)
            * (((1.0000000000000000000_f64) + (__intermediate_result_12))
                .powf(-0.50000000000000000000_f64))
            * ((s).asinh())
            * (__intermediate_result_23)))
        * (if (((s).sqrt())
            + (-((__intermediate_result_14).sinh()))
            + ((5.23500000000000_f64) * ((s).recip()))
            + ((12.4000000000000_f64) * ((s).powf(-2.24000000000000_f64)))
            + ((-0.693962526023595_f64) * (s))
            + (-((__intermediate_result_9) * (__intermediate_result_17)))
            + ((__intermediate_result_12)
                * (__intermediate_result_19)
                * (__intermediate_result_23)))
            .abs()
            == 0.0_f64
        {
            (((s).sqrt())
                + (-((__intermediate_result_14).sinh()))
                + ((5.23500000000000_f64) * ((s).recip()))
                + ((12.4000000000000_f64) * ((s).powf(-2.24000000000000_f64)))
                + ((-0.693962526023595_f64) * (s))
                + (-((__intermediate_result_9) * (__intermediate_result_17)))
                + ((__intermediate_result_12)
                    * (__intermediate_result_19)
                    * (__intermediate_result_23)))
        } else {
            (((s).sqrt())
                + (-((__intermediate_result_14).sinh()))
                + ((5.23500000000000_f64) * ((s).recip()))
                + ((12.4000000000000_f64) * ((s).powf(-2.24000000000000_f64)))
                + ((-0.693962526023595_f64) * (s))
                + (-((__intermediate_result_9) * (__intermediate_result_17)))
                + ((__intermediate_result_12)
                    * (__intermediate_result_19)
                    * (__intermediate_result_23)))
                .signum()
        }))
}

#[test]
fn test_scalar() {
    let sv = 2.4;
    let s: Ad<1> = Ad::active_uni(2.4);
    let g = s.powi(3).grad()[(0, 0)];
    assert_abs_diff_eq!(g, 3.0 * sv * sv, epsilon = EPS);

    let sv = -3.42;
    let s: Ad<1> = Ad::active_uni(sv);
    let g = s.sin().mul(&s).grad()[(0, 0)];
    let h = s.sin().mul(&s).hess()[(0, 0)];
    assert_abs_diff_eq!(g, sv * sv.cos() + sv.sin(), epsilon = EPS);
    assert_abs_diff_eq!(h, 2.0 * sv.cos() - sv * sv.sin(), epsilon = EPS);

    let sv = -3.42;
    let s: Ad<1> = Ad::active_uni(sv);
    let g = s.sin().mul(&s).grad()[(0, 0)];
    let h = s.sin().mul(&s).hess()[(0, 0)];
    assert_abs_diff_eq!(g, sv * sv.cos() + sv.sin(), epsilon = EPS);
    assert_abs_diff_eq!(h, 2.0 * sv.cos() - sv * sv.sin(), epsilon = EPS);

    let sv = 1.4623;
    let s: Ad<1> = Ad::active_uni(sv);
    let expr = s
        .cosh()
        .mul(&s.sinh().mul(&1.245.div_var(&s.powi(-2))))
        .add(&s.tanh());
    let g = expr.grad()[(0, 0)];
    assert_abs_diff_eq!(g, grad_0(sv), epsilon = EPS);
    let h = expr.hess()[(0, 0)];
    assert_abs_diff_eq!(h, hess_0(sv), epsilon = EPS);

    let sv = 31.8;
    let s: Ad<1> = Ad::active_uni(sv);
    let expr = s
        .tan()
        .mul(&s.asinh())
        .mul(&s)
        .sub(&s.powf(1.3).mul(&s.cos()))
        .add(&s.sqrt());
    let g = expr.grad()[(0, 0)];
    assert_abs_diff_eq!(g, grad_1(sv), epsilon = EPS);
    let h = expr.hess()[(0, 0)];
    assert_abs_diff_eq!(h, hess_1(sv), epsilon = EPS);

    // ############################### relative criteria ###############################

    let sv = 0.2127;
    let s: Ad<1> = Ad::active_uni(sv);
    let expr = s
        .tan()
        .mul(&s.asinh().mul(&s.atanh()))
        .mul(&s)
        .sub(&s.powf(1.3).mul(&s.cos()))
        .add(&s.sqrt())
        .sub(&s.div_value(1.441).add(&s.recip()))
        .sub(&(-6.235).div_var(&s));

    let g = expr.grad()[(0, 0)];
    float_close(g, grad_2(sv));
    let h = expr.hess()[(0, 0)];
    float_close(h, hess_2(sv));

    let sv = 0.8235;
    let s: Ad<1> = Ad::active_uni(sv);
    let expr = s
        .tan()
        .mul(&s.asinh().square())
        .mul(&s)
        .sub(&s.powf(1.3).mul(&s.cos()))
        .add(&s.sqrt())
        .sub(&s.div_value(1.441).add(&s.recip()))
        .sub(&(-6.235).div_var(&s).add(&s.powi(3).sinh()))
        .add(&(s.powf(-1.24).div(&s.div_value(12.4).abs())))
        .abs();

    let g = expr.grad()[(0, 0)];
    float_close(g, grad_3(sv));
}

#[test]
fn test_norm_1() {
    const N_TEST_MAT_1: usize = 30;

    let mut rng = thread_rng();
    // let vals = &[1.2, -4.2, 2.4, 0.4];
    let vals: &[f64] = &(0..N_TEST_MAT_1)
        .map(|_| rng.gen_range(-4.0..4.0))
        .collect::<Vec<_>>();

    // core logic #########################################################
    let s: SVector<Ad<N_TEST_MAT_1>, N_TEST_MAT_1> = Ad::active_from_slice(vals);
    let z = s.l2_norm();
    // core logic ends ####################################################

    // Here's how we might compute the expected gradient for L2 norm:
    // The gradient of the L2 norm with respect to x_i is x_i / ||x||
    let norm = (vals.iter().map(|&x| x * x).sum::<f64>()).sqrt();
    let expected_grad = SVector::<f64, N_TEST_MAT_1>::from_row_slice(
        &vals.iter().map(|&x| x / norm).collect::<Vec<f64>>(),
    );

    // Check if the gradients are close enough to the expected values
    let g_diff = (expected_grad - z.grad()).norm_squared();
    assert_abs_diff_eq!(g_diff, 0.0, epsilon = EPS);

    let h = z.hess;
    let expected_hess = (SMatrix::<f64, N_TEST_MAT_1, N_TEST_MAT_1>::identity()
        - expected_grad * expected_grad.transpose())
        / norm;
    let h_diff = (h - expected_hess).norm_squared();
    assert_abs_diff_eq!(h_diff, 0.0, epsilon = EPS);

    println!("Grad difference: {g_diff}\nHessian Difference: {h_diff}");
}

#[test]
fn test_norm_2() {
    const N_TEST_MAT_2: usize = 3;
    type NaConst = Const<N_TEST_MAT_2>;
    const N_VEC_2: usize = N_TEST_MAT_2 * N_TEST_MAT_2;

    let mut rng = thread_rng();
    // let vals = &[1.2, -4.2, 2.4, 0.4];
    let vals: &[f64] = &(0..N_VEC_2)
        .map(|_| rng.gen_range(-4.0..4.0))
        .collect::<Vec<_>>();

    // core logic #########################################################
    let s: SVector<Ad<N_VEC_2>, N_VEC_2> = Ad::active_from_slice(vals);
    let z = s.clone().reshape_generic(NaConst {}, NaConst {});
    let tr = (z.transpose() * z).trace();
    // core logic ends ####################################################

    // dbg!(&tr.grad());
    let expected_grad = s.scale(2.0);
    let g_diff = (expected_grad.value() - tr.grad()).norm_squared();
    assert_abs_diff_eq!(g_diff, 0.0, epsilon = EPS);

    assert_eq!(tr.hess, SMatrix::<f64, 9, 9>::identity() * 2.0);
}
