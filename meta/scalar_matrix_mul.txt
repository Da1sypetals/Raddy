
impl<const N: usize, const R: usize, const C: usize> Mul<SMatrix<Scalar<N>, R, C>> for Scalar<N> {
    type Output = SMatrix<Scalar<N>, R, C>;

    fn mul(self, rhs: SMatrix<Scalar<N>, R, C>) -> Self::Output {
        let mut res = rhs.clone();
        res *= self.clone();
        return res;
    }
}

impl<const N: usize, const R: usize, const C: usize> Mul<SMatrix<Scalar<N>, R, C>> for &Scalar<N> {
    type Output = SMatrix<Scalar<N>, R, C>;

    fn mul(self, rhs: SMatrix<Scalar<N>, R, C>) -> Self::Output {
        let mut res = rhs.clone();
        res *= self.clone();
        return res;
    }
}

impl<const N: usize, const R: usize, const C: usize> Mul<&SMatrix<Scalar<N>, R, C>> for Scalar<N> {
    type Output = SMatrix<Scalar<N>, R, C>;

    fn mul(self, rhs: &SMatrix<Scalar<N>, R, C>) -> Self::Output {
        let mut res = rhs.clone();
        res *= self.clone();
        return res;
    }
}

impl<const N: usize, const R: usize, const C: usize> Mul<&SMatrix<Scalar<N>, R, C>> for &Scalar<N> {
    type Output = SMatrix<Scalar<N>, R, C>;

    fn mul(self, rhs: &SMatrix<Scalar<N>, R, C>) -> Self::Output {
        let mut res = rhs.clone();
        res *= self.clone();
        return res;
    }
}
